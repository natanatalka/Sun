import { Injectable, Injector } from '@angular/core';
import { Headers, Http } from '@angular/http';
import { config } from '../config';
import { options } from '../options';
import { PowwowLoginConfig } from '../types';
import { AppService } from './app.service';
import { UiService } from './ui.service';
import { WsService } from './ws.service';

@Injectable()
export class PowwowLoginService {
  private pwConfig: PowwowLoginConfig;
  private arsUrl: string = localStorage.getItem('arsUrl');
  private appName: string = localStorage.getItem('appName');
  private cachedCredentials;
  private appSourcesRequireRefresh: boolean = false;
  private updateTokenTimeoutId: number;

  constructor(
    private uiService: UiService,
    private injector: Injector,
    private http: Http
  ) {}

  initialize(): Promise<any> {
    return new Promise<any>((resolve, reject) => {
      this.http.get('published.json')
        .map(res => res.json())
        .subscribe(
          (res) => {
            this.pwConfig = {
              cbUrl: (this.pwConfig && this.pwConfig.cbUrl) ? this.pwConfig.cbUrl : res.cbUrl,
              defaultCbUrl: res.cbUrl,
              appVersion: res.version
            };
            localStorage.setItem('appName', res.id);
            return resolve();
          },
          (error) => {
            console.debug('Error getting  published.json ' + error);
            return reject(error);
          }
        );
    });
  }

  login(username: string, password: string): Promise<any> {
    return new Promise<any>((resolve, reject) => {
      let urlSearchParams = new URLSearchParams();
      urlSearchParams.append('login_username', username);
      urlSearchParams.append('login_password', password);
      urlSearchParams.append('app_id', this.appName);
      let body = urlSearchParams.toString();
      let headers = new Headers();
      headers.append('Content-Type', 'application/x-www-form-urlencoded');
      this.http.post(this.pwConfig.cbUrl + '/resources/login', body, {
        headers: headers
      })
        .map(res => res.json())
        .subscribe(
          (res) => {
            this.cachedCredentials = {
              username: username,
              password: password
            };
            console.log('Login success for ' + username);
            this.arsUrl = res.config.arsUrl;
            this.injector.get(AppService).powwowLogin = true;
            localStorage.setItem('arsUrl', res.config.arsUrl);
            localStorage.setItem('token', res.token);
            return this.connectToTheApp(true, resolve, reject);
          },
          (error) => {
            return reject(error);
          }
        );
    });
  }

  connect(connectURL: string): void {
    let sessionId = localStorage.getItem('sessionId');
    options.rpcUrl = connectURL;
    options.connectUrl = this.arsUrl + '/resources/sessions/status/' + sessionId;
    options.isWebSocket = connectURL.indexOf('http') !== 0;
    this.injector.get(AppService).alreadyConnected = true;
    if (options.isWebSocket) {
      this.injector.get(WsService).reconnect();
    }
  };

  close(otherUserConnected?: boolean) {
    this.powwowLogout(otherUserConnected);
  }

  getCachedCredentials() {
    return this.cachedCredentials;
  }

  clearCachedCredentials() {
    this.cachedCredentials = null;
    localStorage.removeItem('sessionId');
    localStorage.removeItem('token');
  }

  checkIfAppRequiresRefresh() {
    return this.appSourcesRequireRefresh;
  }

  setCbURL(val?: string) {
    this.pwConfig.cbUrl = val ? val : this.pwConfig.defaultCbUrl;
  }

  reconnect(): Promise<any> {
    return new Promise<any>((resolve, reject) => {
      if (localStorage.getItem('sessionId') && localStorage.getItem('token')) {
        return this.connectToTheApp(false, resolve, reject);
      } else {
        return reject(new Error('There is no api key or token'));
      }
    });
  }

  // ----------------------------------------------------------------------------------------------

  private powwowLogout(otherUserConnected: boolean): void {
    let sessionId = localStorage.getItem('sessionId');
    clearTimeout(this.updateTokenTimeoutId);
    if (!otherUserConnected) {
      this.http.delete(this.arsUrl + '/resources/sessions/' + sessionId, this.getRequestOptions())
        .subscribe(
          () => {
          },
          (error) => {
            console.error('Error occurred on powwowLogout ', error);
          },
          () => {
            this.clearCachedCredentials();
            window.location.reload();
          }
        );
    } else {
      this.clearCachedCredentials();
      window.location.reload();
    }
  };

  private connectToTheApp(isLoginAction: boolean, resolve, reject): Promise<any> {
    try {
      this.http.post(
        this.arsUrl + '/resources/sessions/',
        {appID: this.appName},
        this.getRequestOptions()
      )
        .map(res => res.json())
        .subscribe(
          (res) => {
            if (res.status === 'connected') {
              this.startUpdateTokenCycle();
              localStorage.setItem('sessionId', res.key);
              if (isLoginAction && typeof window['cordova'] !== 'undefined'
                && window['cordova'].PowwowPlugin.updateAppSources) {
                return this.checkIfAppRequiresUpdate(res);
              } else {
                return resolve(res.url);
              }
            } else {
              return reject(new Error('Error connecting: ' + res.status));
            }
          },
          (error) => {
            this.clearCachedCredentials();
            return reject(new Error('Error connecting: ' + error));
          }
        );
    } catch (error) {
      return reject(error);
    }
  };

  private updateLoginToken(resolve, reject, updateTokenFunction): Promise<any> {
    try {
      this.http.get(this.pwConfig.cbUrl + '/resources/token/refresh', this.getRequestOptions())
        .map(res => res.json())
        .subscribe(
          (res) => {
            localStorage.setItem('token', res.token);
            updateTokenFunction();
            return resolve(res.token);
          },
          (error) => {
            console.error('Error updating Login Token ', error);
            return reject(error);
          }
        );
    } catch (error) {
      return reject(error);
    }
  }

  private startUpdateTokenCycle() {
    let updateTokenFunction = () => {
      return new Promise<void>((resolve, reject) => {
        setTimeout(() => {
          return this.updateLoginToken(resolve, reject, updateTokenFunction);
        }, config.refreshTokenInterval);
      });
    };
    updateTokenFunction();
  }

  private versionCompare(published?: string, current?: string) {
    if (typeof published + typeof current != 'stringstring')
      return false;
    let a: Array<any> = published.split('.')
      , b: Array<any> = current.split('.')
      , len = Math.max(a.length, b.length);
    for (let i = 0; i < len; i++) {
      if ((a[i] && !b[i] && a[i] > 0) || (a[i] > b[i])) {
        return 1;
      } else if ((b[i] && !a[i] && b[i] > 0) || (a[i] < b[i])) {
        return -1;
      }
    }
    return 0;
  };

  private checkIfAppRequiresUpdate(data: any): Promise<any> {
    try {
      this.http.get(data.smartuxApp)
        .map(res => res.json())
        .subscribe(
          (res) => {
            let publishedAppVersion = res.version;
            if (this.versionCompare(publishedAppVersion, this.pwConfig.appVersion) === 1) {
              this.uiService.hideLoading();
              window['cordova'].PowwowPlugin.updateAppSources(data.appZip, () => {
                this.appSourcesRequireRefresh = true;
                return Promise.resolve(data.url);
              });
            } else {
              return Promise.resolve(data.url);
            }
          },
          (error) => {
            console.error('Error getting  smartuxApp.json ', error);
            return Promise.resolve(data.url);
          }
        );
    } catch (error) {
      return Promise.reject(error);
    }
  };

  private getRequestOptions() {
    let authorizationHeaders = new Headers();
    authorizationHeaders.append('Authorization', 'bearer ' + localStorage.getItem('token'));
    return {
      headers: authorizationHeaders,
      withCredentials: true
    };
  }
}
