import { Injectable, Injector } from '@angular/core';
import { Headers, Http } from '@angular/http';
import { parse, stringify } from 'query-string';
import { config } from '../config';
import { options } from '../options';
import { AppService } from './app.service';
import { PowwowLoginService } from './powwow-login.service';
import { UiService } from './ui.service';

@Injectable()
export class WsService {
  private messageListeners: ((event: MessageEvent) => void)[] = [];
  private connection: WebSocket;
  private initParams: any;
  private isConnecting: boolean = false;

  constructor(
    private uiService: UiService,
    private injector: Injector,
    private http: Http
  ) {}

  connect(params: any): void {
    if (this.connection) {
      return;
    }
    this.uiService.showLoading(config.messages.connecting);
    this.initParams = params;
    if (options.rpcUrl) {
      this.connection = new WebSocket(options.rpcUrl);
      this.addListeners();
    } else if (options.connectUrl) {
      this.connectUsingSessionUrl();
    }
  }

  getInstance() {
    return this.connection;
  }

  reconnect() {
    this.doReconnect(true);
  }

  onMessage(listener: (event: MessageEvent) => void): void {
    this.messageListeners.push(listener);
  }

  isConnected(): boolean {
    return this.connection && this.connection.readyState === WebSocket.OPEN;
  }

  send(data: any): void {
    this.connection.send(JSON.stringify(data));
  }

  // ----------------------------------------------------------------------------------------------

  private addListeners(isReconnect?: boolean) {
    this.connection.addEventListener('open', () => {
      if (isReconnect) {
        this.isConnecting = false;
      }
      console.log('Connected to ' + options.rpcUrl);
      this.send({
        jsonrpc: '2.0',
        method: 'initialize',
        params: this.initParams
      });
      this.uiService.showLoading(config.messages.init);
      for (let listener of this.messageListeners) {
        this.connection.addEventListener('message', listener);
      }
    });

    this.connection.addEventListener('close', (closeEvent) => {
      let code = closeEvent.code;
      let reason = closeEvent.reason;

      console.debug(`Websocket connection closed with reason ${reason} and code ${code}`);
      if (code === 1000 && window.location.hash == 'updateSources') {
        window.location.hash = '';
        return;
      }
      // check session status with connect Url.
      // added check on reason because UWP app doesn't support closeEvent.code correctly.
      if (code === 4005 || reason === 'Already connected') {
        this.alreadyConnected();
      } else if (options.connectUrl) {
        this.updateSessionStatus();
      } else if (options.rpcUrl) {
        this.doReconnect();
      }
    });
  };

  /**
   * Show confirmation popup if user has been connected from another device
   * If confirmed, user is reconnected
   * if not, user is logged out
   */
  private alreadyConnected() {
    this.uiService.alert(config.messages.alreadyConnected, config.messages.doReconnect, [{
      text: 'Yes',
      handler: () => this.updateSessionStatus()
    }, {
      text: 'No',
      handler: () => this.injector.get(AppService).logout(true)
    }]);
  }

  /**
   * Update session status using connectURL
   * if session is connected, websocket is automatically reconnected to it
   * if connectURL is not reachable, application tries to reconnect to the last websocket url
   */
  private updateSessionStatus() {
    if (!options.connectUrl) {
      this.doReconnect();
      return;
    }
    let authorizationHeaders = new Headers();
    authorizationHeaders.append('Authorization', 'bearer ' + localStorage.getItem('token'));

    this.http.get(options.connectUrl, {
      headers: authorizationHeaders,
      withCredentials: true
    })
      .map(res => res.json())
      .subscribe(
        (res) => {
          let sessionExists = res.status === 'connected';
          if (sessionExists) {
            // If we're still connected, there must have been some hiccup in the connected,
            // try reconnecting.
            console.debug('Session is still connected, trying to reconnect websocket');
            this.doReconnect();
          } else {
            // Otherwise, the session isn't valid, logout!
            console.debug('Session is invalid, logging out');
            this.returnToLaunch();
          }
        },
        (error) => {
          if (error.status == 404 || error.status == 401) {
            this.injector.get(PowwowLoginService).clearCachedCredentials();
            window.location.reload();
          } else {
            // If the connection failed, try reconnecting again.
            console.debug('Unable to reach connect Url, trying to reconnect websocket');
            this.doReconnect();
          }
        }
      );
  }

  private doReconnect(isReconnecting?: boolean) {
    if (!this.isConnecting && !isReconnecting) {
      this.uiService.showLoading(config.messages.connectionLost);
      this.isConnecting = true;
    }
    this.connection = new WebSocket(options.rpcUrl);
    this.addListeners(true);
  }

  private connectUsingSessionUrl() {
    this.http.get(options.connectUrl)
      .map(res => res.json())
      .subscribe(
        (res) => {
          if (res.status === 'connected') {
            if (!options.hasExplicitRpcUrl) {
              options.rpcUrl = res.url;
            }
            // If we're still connected, there must have been some hiccup in the connected,
            // try reconnecting.
            console.debug('Session is connected, connect websocket');
            this.doReconnect();
          } else {
            console.debug('Server responded wrong status, trying again ' + res);
            this.unableToAccess();
          }
        },
        (error) => {
          console.debug('Unable to connect to server, trying again. ' + error);
          this.unableToAccess();
        }
      );
  }

  private unableToAccess() {
    this.uiService.hideLoading();
    this.uiService.alert('Connection Error', 'Unable to access ' + options.connectUrl, [{
      text: 'Retry',
      handler: () => this.returnToLaunch()
    }]);
  }

  /**
   * Return to the login screen
   */
  private returnToLaunch() {
    let queryParams = parse(window.location.search);
    if (queryParams.sessionURL) {
      delete queryParams.sessionURL;
      delete queryParams.endSessionURL;
      window.location.href = window.location.href.split('?')[0] + '?' + stringify(queryParams);
    } else {
      window.location.reload();
    }
  }
}
