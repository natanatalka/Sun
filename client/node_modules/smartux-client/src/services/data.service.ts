import { Injectable } from '@angular/core';
import * as _ from 'lodash';
import { DiffObjectPath, ModelProp, ModelPropsMap, Params, ScreenModel, SelectData } from '../types';
import { ScreenModelService } from './screen-model.service';
import { ScreenService } from './screen.service';

@Injectable()
export class DataService {

  constructor(
    private screenModelService: ScreenModelService,
    private screenService: ScreenService
  ) {}

  // Process the response data:
  async processResponse(appData, responseData, screenId?): Promise<any> {
    let data = {};
    this.chooseSelectItems(responseData);
    // If request is for a partial field update and we already have data for the current screen
    if (responseData.$$partialFields) {
      data = _.cloneDeep(appData);
      this.applyDiffObject(data, responseData);
    } else {
      data = responseData;
    }
    this.screenService.updateDataStubs(data, screenId);
    return data;
  }

  // Get the request params from the screen data automatically:
  async populateParams(data: any, method: string, params?: Params): Promise<Params> {
    let screenId = this.screenService.getCurrentId();
    let screenModel = await this.screenModelService.getById(screenId);
    let [modelName, methodName] = method.split('.');
    if (modelName && !params) {
      params = {};
      if (screenModel[methodName] && screenModel[methodName].parameters) {
        let paramsDef = screenModel[methodName].parameters;
        this.copyParams(params, paramsDef, data);
      }
    }
    params = _.cloneDeep(params);
    this.processParams(params);
    return params;
  }

  // If there are selects in the data, let's choose the right selected item:
  chooseSelectItems(data: any): void {
    if (!data) {
      return;
    }
    let isSelect = data.hasOwnProperty('options') && data.hasOwnProperty('selected') && data.options.length;
    let isSelectedSingleValue = _.isObject(data.selected) && data.selected.hasOwnProperty('value');
    let isSelectedArray = _.isArray(data.selected);
    if (isSelect) {
      if (isSelectedSingleValue) {
        for (let option of data.options) {
          if (option.value === data.selected.value || option.label === data.selected.label) {
            data.selected = option;
          }
        }
      } else if (isSelectedArray) {
        for (let option of data.options) {
          for (let i = 0; i < data.selected.length; i++) {
            if (option.value === data.selected[i].value || option.label === data.selected[i].label) {
              data.selected[i] = option;
              option.selected = true;
            }
          }
        }
      }
    } else if (_.isObject(data)) {
      _.each(data, (value) => {
        this.chooseSelectItems(value);
      });
    }
  }

  // Returns 'true' if item is selected:
  isSelected(selectData: SelectData, item: string): boolean {
    if (_.isArray(selectData.selected)) {
      return selectData.selected.indexOf(item) > -1;
    } else {
      return selectData.selected === item;
    }
  }

  // Toggle selection of the item:
  toggleSelection(selectData: SelectData, item: string) {
    if (_.isArray(selectData.selected)) {
      let index = selectData.selected.indexOf(item);
      if (index > -1) {
        selectData.selected.splice(index, 1);
      } else {
        selectData.selected.push(item);
      }
    } else {
      if (selectData.selected === item) {
        selectData.selected = null;
      } else {
        selectData.selected = item;
      }
    }
  }

  // Get data for 'action' call:
  getDataForAction(screenModel: ScreenModel, data) {
    let dataCopy = _.cloneDeep(data);
    this.processActionData(screenModel, dataCopy);
    return dataCopy;
  }

  // This is used in case of $$partialUpdateFields:
  applyDiffObject(dest: any, src: any) {
    let numUpdates = src.$$partialFields.full.length;
    for (let i = 0; i < numUpdates; i++) {
      let toField = src.$$partialFields.full[i];
      let fromField = src.$$partialFields.part[i];
      this.applyDiffSubObject(dest, src, fromField, toField);
    }
  }

  processScreenData(properties, data) {
    _.each(properties, (property, key) => {
      switch (property.type) {
      case 'object':
        if (!data[key]) {
          data[key] = {};
        }
        this.processScreenData(property.properties, data[key]);
        break;
      case 'array':
        if (!data[key]) {
          data[key] = [];
        }
        break;
      case 'select':
        if (!data[key]) {
          data[key] = {};
        }
        if (!data[key].options) {
          data[key].options = [];
        }
        if (!data[key].selected) {
          data[key].selected = {};
        }
        break;
      }
    });
  }

  public replaceObjectWithIndex(action: string, indices: number[]): string {
    let regExp = /\[([^\]]+)\]/g;
    let matchAction = action.match(regExp);

    if (matchAction) {
      for (let i = 0; i < matchAction.length; i++) {
        action = action.replace(matchAction[i], `[${indices[i]}]`);
      }
    }
    return action;
  }

  // ----------------------------------------------------------------------------------------------

  private processParams(params: Params) {
    _.each(params, (value, key) => {
      if (value && !this.processSelectInParams(value, params, key) && _.isObject(value)) {
        this.processParams(value);
      }
    });
  }

  private processSelectInParams(data: any, container: Params, key: string) {
    let isSelect = data.hasOwnProperty('options') && data.hasOwnProperty('selected') && data.options.length;
    let isSelectedNull = data.selected === null;
    let isSelectedSingleValue = _.isObject(data.selected) && data.selected.hasOwnProperty('value');
    let isSelectedArray = _.isArray(data.selected);
    if (!isSelect) {
      return false;
    }
    if (isSelectedNull) {
      container[key] = null;
      return true;
    } else if (isSelectedSingleValue) {
      container[key] = data.selected.value;
      return true;
    } else if (isSelectedArray) {
      container[key] = [];
      for (let item of data.selected) {
        container[key].push(item.value);
      }
      return true;
    }
  }

  private copyParams(params: Params, paramsDef: ModelPropsMap, data: any) {
    _.each(paramsDef, (paramDef, paramName) => {
      if (data.hasOwnProperty(paramName)) {
        if (paramDef.type === 'object' && paramDef.hasOwnProperty('properties')) {
          let subParams = {};
          this.copyParams(subParams, paramDef.properties, data[paramName]);
          params[paramName] = subParams;
        } else {
          params[paramName] = data[paramName];
        }
      }
    });
  }

  private processActionData(propDef: ModelProp, data, propName?) {
    if (propDef.update && (propDef.update.type === 'none' || propDef.update.type == 'change' && propName)) {
      delete data[propName];
      return;
    }
    let subData = propName ? data[propName] : data;
    if (subData) {
      if (propDef.type === 'array' && _.isArray(subData)) {
        for (let item of subData) {
          this.processActionData(propDef.items, item);
        }
      } else if (propDef.type === 'object' && _.isObject(subData)) {
        _.each(propDef.properties, (value, key) => {
          this.processActionData(value, subData, key);
        });
      }
    }
  }

  private applyDiffSubObject(dest: any, src: any, fromField: string, toField: string) {
    let tf = this.parseObjectPath(toField);
    let ff = this.parseObjectPath(fromField);
    let isLastObject = ff.remainingPath.length == 0;
    if (tf.isArray) {
      if (isLastObject) {
        dest[tf.field][tf.index] = src[ff.field][ff.index];
      } else {
        this.applyDiffSubObject(dest[tf.field][tf.index], src[ff.field][ff.index], ff.remainingPath, tf.remainingPath);
      }
    } else {
      if (isLastObject) {
        dest[tf.field] = src[ff.field];
      } else {
        this.applyDiffSubObject(dest[tf.field], src[ff.field], ff.remainingPath, tf.remainingPath);
      }
    }
  }

  private parseObjectPath(objectPath): DiffObjectPath {
    let posFirstObj = objectPath.indexOf('.');
    let fieldPart;
    let remainingPath = '';
    if (posFirstObj == -1) {
      fieldPart = objectPath;
    } else {
      fieldPart = objectPath.substring(0, posFirstObj);
      remainingPath = objectPath.substring(posFirstObj + 1);
    }
    let posArrayStart = fieldPart.indexOf('[');
    if (posArrayStart == -1) {
      // Not an array, we have fieldPart.
      return {field: fieldPart, isArray: false, remainingPath: remainingPath};
    } else {
      let fieldIndex;
      let posArrayEnd = fieldPart.indexOf(']', posArrayStart + 1);
      if (posArrayEnd == -1) {
        throw ('No end block in ' + fieldPart + '.');
        // Throw an error, this is wrong!
      } else {
        let indexPart = fieldPart.substring(posArrayStart + 1, posArrayEnd);
        fieldIndex = parseInt(indexPart);
        if (isNaN(fieldIndex)) {
          throw ('Field index in ' + fieldPart + ' is not a number.');
        }
      }
      fieldPart = fieldPart.substring(0, posArrayStart);
      // Now we have fieldPart and fieldIndex.
      return {field: fieldPart, isArray: true, index: fieldIndex, remainingPath: remainingPath};
    }
  }

}
