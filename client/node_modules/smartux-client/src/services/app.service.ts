import { Injectable, Injector } from '@angular/core';
import { Http } from '@angular/http/http';
import * as _ from 'lodash';
import 'rxjs/add/operator/filter';
import { ApiService } from '../api/api.service.abstract';
import { options } from '../options';
import { BaseScreen } from '../screen';
import { AppHooks, Params } from '../types';
import { DataService } from './data.service';
import { DeviceService } from './device.service';
import { MockService } from './mock.service';
import { NavigationService } from './navigation.service';
import { PowwowLoginService } from './powwow-login.service';
import { ScreenModelService } from './screen-model.service';
import { ScreenService } from './screen.service';
import { UiService } from './ui.service';

@Injectable()
export class AppService {
  appHooks: AppHooks;

  public alreadyConnected: boolean = false;
  public powwowLogin: boolean = !!localStorage.getItem('arsUrl');
  public hideLogin: boolean = false;
  public loginScreen: string = 'Login';
  public loginAction: string = 'submit';
  private http: Http;

  constructor(
    private injector: Injector,
    private dataService: DataService,
    private screenService: ScreenService,
    private screenModelService: ScreenModelService,
    private uiService: UiService,
    private deviceService: DeviceService,
    private navigationService: NavigationService
  ) {}

  private fieldChangePending;

  /**
   * Initialize the application.
   */
  initialize(hooks: AppHooks) {
    this.appHooks = hooks;
    this.deviceService.orientation$.subscribe(() => {
      let screenId = this.screenService.getCurrentId();
      this.navigationService.go(screenId, false); // handle the new orientation
    });
  }

  // Make a call to the server. If there are no params given, use the screen data
  async call(method: string, params?: Params, noLoading?: boolean, context?: BaseScreen) {
    if (!noLoading) {
      this.uiService.showLoading();
    }
    if (context && context.data) {
      params = await this.dataService.populateParams(context.data, method, params);
    }
    // TODO: move this logic to PowwowLogin
    let isLoginSubmit = method === 'action' && params.model === this.loginScreen && params.action === this.loginAction;
    //check if we need to use powwowLogin, if so - call this.login
    if (!this.alreadyConnected && isLoginSubmit && options.rpcUrl !== 'mock' && !options.hasExplicitRpcUrl) {
      let credentials = params.data;
      if (!credentials.username || !credentials.password) {
        this.uiService.alert('Error Logging in', 'Username or password fields are incorrect');
      }
      this.login(credentials);
    } else {
      this.injector.get(ApiService).request(method, params, context);
    }
  }

  // Set the pending fiend change
  setFieldChangePending(changePending) {
    this.fieldChangePending = changePending;
    console.log('setFieldChangePending:', changePending);
  }

  async updateField(fieldModel: string, value: any, params: any) {
    params.model = this.screenService.getCurrentId();
    params.data = {};
    params.data[fieldModel] = value;
    if (this.fieldChangePending) {
      console.log('Field change pending so putting of action till update is done...');
    } else {
      this.call('update', params);
    }
  }

  async relatedScreen(screenId: string, refresh: boolean) {
    this.call('screen', {screen: screenId, refresh: refresh});
  }

  // Send a "method" call to the server
  async method(method: string, params: any, context: BaseScreen) {
    params = params || {};
    let screenId = this.screenService.getCurrentId();
    this.call('method', {model: screenId, method: method, params: params}, false, context);
  }

  // Send an "action" call to the server
  async action(action: string, indices: number[] | number, timeout: number, context: BaseScreen) {
    if (_.isNumber(indices)) {
      timeout = indices;
      indices = null;
    }
    if (this.fieldChangePending) {
      console.log('Field change pending so putting of action till update is done...');
    } else {
      if (_.isArray(indices)) {
        action = this.dataService.replaceObjectWithIndex(action, indices);
      }
      let screenId = this.screenService.getCurrentId();
      let screenModel = await this.screenModelService.getById(screenId);
      let data = screenModel ? this.dataService.getDataForAction(screenModel, context.data) : context.data;
      this.call('action', {model: screenId, action: action, data: data, timeout: timeout}, false, context);
    }
  }

  // Report an issue
  reportIssue() {
    this.injector.get(ApiService).request('reportIssue', {});
  };

  // Perform appLogin or reconnect in case we have no options.rpcUrl
  establishConnection() {
    if (options.rpcUrl == 'mock' || options.hasExplicitRpcUrl) {
      console.log('App already connected or using mocks');
      this.hideLogin = false;
      this.uiService.hideLoading();
      return;
    }
    this.uiService.showLoading('Establishing connection');
    let powwowLoginService = this.injector.get(PowwowLoginService);
    if (this.alreadyConnected) {
      console.log('Calling powwowLoginService getcachedcredentials');
      let credentials = powwowLoginService.getCachedCredentials();
      if (!credentials || !credentials.username) {
        console.log('No cached credentials');
        // if no user credentials we cannot perform App login - forvard user to loginScreen
        powwowLoginService.clearCachedCredentials();
        window.location.reload();
        return;
      }
      this.call('action', {model: this.loginScreen, action: this.loginAction, data: credentials});
    } else {
      powwowLoginService.reconnect().then((url) => {
        console.log('Reconnect success: ' + url);
        powwowLoginService.connect(url);
      }).catch(() => {
        this.hideLogin = false;
        this.navigationService.openStartScreen();
        this.uiService.hideLoading();
      });
    }
  }

  // End the session using the end session URL
  endSession() {
    if (options.endSessionURL) {
      this.uiService.hideMenu();
      this.uiService.showLoading('Ending session');

      this.http.get(options.endSessionURL);
    }
  }

  // Perform CB login and connect to the session if no options.rpcUrl
  login(credentials): boolean {
    this.uiService.showLoading('Logging in');
    this.injector.get(PowwowLoginService).login(credentials.username, credentials.password).then((url) => {
      console.log('Login success: ' + url);
      this.injector.get(PowwowLoginService).connect(url);
    }).catch((error) => {
      console.log('Login error: ', error);
      let message = (error.data && error.data.message) ? error.data.message :
        'powwowLogin: An unexpected error occurred.';
      this.uiService.alert('Login error', message);
    });
    return false;
  }

  // Get app settings from mobile device
  getAppSettings(showSettings?: boolean): Promise<any> {
    if (typeof window['cordova'] === 'object' && window['cordova'].PowwowPlugin
      && window['cordova'].PowwowPlugin.getAppSettings) {
      window['cordova'].PowwowPlugin.getAppSettings(showSettings).then((res) => {
        if (showSettings) {
          this.uiService.hideMenu();
        }
        console.log('cbUrl from mobile settings - ' + res.cbUrl);
        this.injector.get(PowwowLoginService).setCbURL(res.cbUrl);
        return Promise.resolve();
      });
    } else {
      return Promise.resolve();
    }
  }

  // Perform application logout
  logout(otherUserConnected?: boolean) {
    console.debug('logout');
    if (this.powwowLogin) {
      this.alreadyConnected = false;
      this.injector.get(PowwowLoginService).close(otherUserConnected);
    } else {
      this.call('logout', {});
    }
  }

  // Change mock-set for a screen
  async updateScreenData(mockSet: string) {
    let screen = await this.screenService.getCurrent();
    screen.mockSet = mockSet;
    let data = await this.injector.get(MockService).getMockData(screen);
    data = await this.dataService.processResponse({}, data, screen.id);
    this.injector.get(ApiService).data$.next(data);
  }
}
